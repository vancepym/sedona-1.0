<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    12 Sep 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Apps</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='logging.html'>Prev</a>
 | <a href='security.html'>Next</a>
</div>
<h1 class='title'>Apps</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The standard design for deploying applications in the Sedona Framework is to utilize
the component model to separate the code from the application.  In
this architecture you have a clean boundary between the code packaged
up as kits and the application packaged up as a tree of components.
This model allows you to build applications simply by assembling
components together, configuring their properties, and linking slots
together to define control flow.  This style of programming is especially
amenable to graphical programming.
</p>

<p>
So when talking about a Sedona Framework application, we are really talking
about a tree of components assembled together.  An application is
purely declarative, all the code is encapsulated in the kits.  The
application itself is stored as a file using one of
two file formats:
</p>

<ul>
<li><b>SAX</b>: is a simple XML representation
of the application that is easily generated and consumed by software
tools</li>
<li><b>SAB</b>: is a compact binary representation
of the application suitable for storage and execution on a Sedona Framework-enabled
device</li>
</ul>

<p>
You can convert between the two file formats using
<a href='sedonac.html#compileApp'>sedonac</a>.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="bootstrap">Boot Strap</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Applications are boot strapped using the following phases:
</p>

<ol>
<li><b>Loaded</b>: all components are loaded from SAB file into
memory and have their <code>Component.loaded</code> callback invoked.</li>
<li><b>Start</b>: all components have their <code>Component.start</code>
callback invoked.</li>
<li><b>Running</b>: the application enters in main loop for
execution (described next).</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="execution">Execution</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The Sedona Framework's execution model is based a single threaded main loop
with a fixed scan rate:
</p>

<ol>
<li>Recursively execute components (children first).  For each component:
  <ol type='a'>
  <li>Propagate incoming links</li>
  <li>Call the <code>Component.execute</code> virtual method</li>
  </ol>
</li>
<li>Give any remaining time in the scan cycle to services via
<code>Service.work</code></li>
<li>If no services have remaining work, then relinquish CPU (via yield or sleep) until next cycle</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="yieldSleep">Yield vs Sleep</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Depending on the underlying execution environment, the App can either
return control to the OS (exit the VM) or sleep until it's time to run again.
</p>
<h2>Preemptive multithreaded OS</h2>
<p>
  These include Windows, Linux or QNX.  When a thread calls the OS sleep
  primitive, other threads are given a chance to run.  The VM may be
  swapped in and out several times during an execute cycle.
</p>
<h2>Main Loop</h2>
<p>
  In this environment, the Sedona VM executes as the main loop and
  all other work is done @ ISR level.  Once the App completes an
  execute cycle, it can delay by entering a busy-wait loop.
</p>
<h2>Cooperative tasking OS </h2>
<p>
In this environment, a task must return control to the scheduler to allow other tasks a chance to run.  The sleep and busy-wait approaches won't work here since the VM will never exit, so the VM must support a clean exit and re-entry. This is accomplished by the yield mechanism described below.
</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="yield">Yield</h1>
<!--/////////////////////////////////////////////////////////-->
<p>
  The Sedona Framework supports <i>yielding</i> to provide a graceful exit (and
  subsequent reentry) of the VM, allowing the CPU to perform other
  operations.
</p>
<p>
  Systems that require yield functionality must override the following
  functions on Platform
</p>
<p>
  <code>yieldRequired()</code> - return true if the VM should exit after each App execute cycle
</p>
<p>
  <code>yield(long yieldTime)</code> - indicates the VM will be exiting and requests to be resumed in yieldTime nanoseconds.
</p>
<p>
  If a Platform returns true to yieldRequired(), then the VM will exit with
  the error code <code>ERR_YIELD</code> after each pass execution loop.  Before
  exiting, <code>yield(yieldTime</code>) will be called indicating how long
  the VM wishes to delay before re-entry.
</p>
<p>
  Native code can resume the VM via <code>vmResume(SedonaVM*)</code>
</p>
<p>
  If vmResume is not called before yieldTime expires, App overruns will occur.
 </p>



<!--/////////////////////////////////////////////////////////-->
<h1 id="hibernation">Hibernation</h1>
<!--/////////////////////////////////////////////////////////-->
<p>
When entering hibernation, the App exits and returns control to the bootstrap code.
It is similar to yield but it is expected that the hibernation time will be much longer
than a typical yield time.  Hibernation is driven by application logic and most likely
will not occur each App execute cycle, whereas yield must occur each cycle.
</p>

<p>
To enter the hibernation state, an application calls <code>App.hibernate()</code>.
This will set a flag on App and when the current execution cycle is complete,
it will cause the App to exit with error code <code>ERR_HIBERNATE</code>.
This will gracefully unwind the call stack, returning control to the boot code.
The device's boot code should then put the device to sleep.  It is a device dependent
issue to decide how it will wake up from hibernation.  When the device does wake, it
should restart the VM with a call to <code>vmResume(SedonaVM*)</code>.  If your device
doesn't support hibernation, then you will need to simulate it using code such
as the following:
</p>

<pre>
result = vmRun(&amp;vm);
while (result == ERR_HIBERNATE)
{
  printf("-- Simulated hibernate --\n");
  result = vmResume(&amp;vm);
}
</pre>

<p>
If you are developing Sedona Framework components, applications, or drivers you should
keep hibernation in mind. Any software that might run on a battery powered
device needs to support hibernation cleanly. This means that function blocks
should assume the scan rate might have hibernation pauses. If you have
services that need to do something special when hibernating or waking, then
you will need to override the functions
<code>Service.onHibernate()</code> and <code>Service.onUnhibernate()</code>.
<code>Service.onHibernate()</code> will be called prior to VM exit.  <code>Service.onUnhibernate()</code> will be called after the VM is resumed and prior to the App execution loop starting back up.

</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="steadystate">Steady State</h1>
<!--/////////// move this after Execution? //////////////////-->

<p>
Most apps will be fully operational by the end of the first cycle.
When hardware I/O is involved, however, an app may need to allow additional time for the
hardware to warm up, or for complex logic results to propagate fully to all components.
For this purpose, the Sedona Framework provides a "steady state" timing feature that should be used
to protect the hardware from reading or writing transient values while the app is
starting up.
</p>

<p>
The steady state feature consists of two pieces:
</p>

<ul>
  <li><b>timeToSteadyState</b>:
  This integer specifies the time delay between the start of app execution and the time at
  which the app is considered to be in "steady state".
  It is a config property of the App class, so it can be set in the app definition (.sax file) or
  at runtime from a remote access tool (e.g. the App property sheet in Sedona Framework Workbench).
  <br/> <br/>
  The default value is 0, meaning that the delay ends when the app enters the "Running"
  phase described above.  The correct value for a given App will vary depending on
  the application logic and the specific hardware involved.
  </li>
  <br/>
  <li><b>isSteadyState()</b>:
  This is a method that returns <code>true</code> if the app has entered
  "steady state" mode, i.e. if the time delay defined by <code>timeToSteadyState</code>
  has elapsed, and <code>false</code> otherwise.  Once steady state mode is reached,
  this method will continue to return <code>true</code> until the app is restarted.
  Code that affects hardware on the native level should use this method to
  avoid reading or writing hardware values until steady state is reached.
  </li>
</ul>

<p>
<b>Note</b>: This feature is not used internally within the App.
It only affects behavior of components that use the <code>isSteadyState()</code> method.
It is the responsibility of each kit developer to call this method as needed to protect the
hardware.
</p>
By default, <code>App.timeToSteadyState</code> applies only to the first time the VM is started.  Once steady time has elapsed, hibernate/yield will not affect it.  If <code>App.hibernationResetsSteadyState</code> is set to true, then the steady state flag will be reset each time device exits hibernation.


<!--/////////////////////////////////////////////////////////-->
<h1 id="links">Links</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Links are the mechanism used to define control flow in an app.
Links are said to be <i>from</i> a given component's slot <i>to</i>
another component's slot.
</p>

<p>
Currently only prop-to-prop links are supported.  During link
propagation, the <i>from-property</i> value is copied into
the <i>to-property</i>.  This mechanism is often used to link
sensor inputs through control logic to actuator outputs.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="services">Services</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Services are special components that subclass from
<a href='sys/Service.html'>sys::Service</a>.  Services have
three primary characteristics that set them apart from other
types of components:
</p>

<ul>
<li><b>Type Lookup</b>: services are easy to lookup by
type via the <code>App.lookupService</code> method.
</li>
<li><b>Background work</b>: most components get a single
callback to do work during a scan cycle.  Services on the other
hand get to handle background work during the time available at
the end of a given scan cycle.
</li>
<li><b>Hibernation control</b>: Each time App finishes an execute
  cycle, it calls <code>Service.canHibernate</code> on all services.
  If a service is not in a state where it can hibernate, it should
  return false.

  For example, if the service is waiting for a network
  reply, it would return false.

  Platform services for devices that never need to hibernate should always return false.
</li>
</ul>

<p>
Services are often used to provide functionality to other components.
For example the <code>UserService</code> is used to lookup and
authenticate user accounts.  Many services such as protocol drivers
also perform background work to service network messages.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="sax">SAX Files</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The SAX format is structured as follows:
</p>

<pre>
&lt;sedonaApp>
&lt;schema>
  &lt;kit name='sys'/>
  ...
&lt;/schema>
&lt;app>
  &lt;comp name="play" id="1" type="sys::Folder">
    &lt;comp name="rampA" id="7" type="control::Ramp">
      &lt;prop name="min" val="20.00000"/>
      &lt;prop name="max" val="80.00000"/>
    &lt;/comp>
    ...
  &lt;/comp>
  ...
&lt;/app>
&lt;links>
  &lt;link from="/play/rampA.out" to="/play/something.else"/>
  ...
&lt;/links>
&lt;/sedonaApp>
</pre>

<p>
<b>&lt;sedonaApp></b> root element that contains:
</p>
<ul>
<li><b>&lt;schema></b>: contains <b>&lt;kit></b> elements</li>
<li><b>&lt;app></b>: contains <b>&lt;comp></b> elements</li>
<li><b>&lt;links></b>: contains <b>&lt;link></b> elements</li>
</ul>

<p>
<b>&lt;kit></b> defines the kits used by the application:
</p>
<ul>
<li><b>name</b>: required kit name</li>
<li><b>checksum</b>: optional kit checksum; if omitted the latest
version of the kit is assumed</li>
</ul>

<p>
<b>&lt;comp></b> defines each component in the application:
</p>
<ul>
<li><b>&lt;comp></b>: nested elements map to nested components</li>
<li><b>&lt;prop></b>: property configuration for the component</li>
<li><b>name</b>: required name of component (limited in length)</li>
<li><b>type</b>: required qname of the component's type</li>
<li><b>id</b>: optional two byte identifier; if omitted an id is auto-generated</li>
</ul>

<p>
<b>&lt;prop></b> defines the property value of a component
within a <b>&lt;comp></b> element.  Supported attributes:
</p>
<ul>
<li><b>name</b>: required name of property</li>
<li><b>val</b>: required value.  Buf properties should be a base64
encoded value (unless asStr in which case just use string value).</li>
</ul>

<p>
<b>&lt;link></b> element defines a link between two slots using
the format of "/path/comp.slot":
</p>
<ul>
<li><b>from</b>: the from component and slot name</li>
<li><b>to</b>: the to component and slot name</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="sab">SAB Files</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
While XML is a nice representation for tools to work with
app files, XML is too big and difficult to work with in an
embedded device.  So we use the SAB format when we need a compact
binary representation.  Sedona Framework devices typically store their
application as an SAB "file" in FLASH (although often it might
just be location or sector of FLASH versus a real file system).
</p>

<p>
Although SAB is a very compact format for applications it must
be used with a matching <a href='schema.html'>schema</a>.  For
example, in order for a Sedona Framework device to load a given SAB file, its scode
must have the exact same kits and checksums installed.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="apis">APIs</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
You can work with both SAX and SAB files in Java using the
<code>sedona.offline</code> APIs:
</p>

<ul>
<li>OfflineApp.encodeAppXml</li>
<li>OfflineApp.decodeAppXml</li>
<li>OfflineApp.encodeAppBinary</li>
<li>OfflineApp.decodeAppBinary</li>
</ul>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='logging.html'>Prev</a>
 | <a href='security.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







