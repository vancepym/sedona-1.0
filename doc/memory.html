<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2008 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    2 Jun 08  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Memory</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='arrays.html'>Prev</a>
 | <a href='nativeMethods.html'>Next</a>
</div>
<h1 class='title'>Memory</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>                                  
Utilizing memory as efficiently as possible is a core requirement
for making Sedona run in small, embedded devices.  We divide
memory into the following sections:
</p>

<ul>
<li><b>Sedona Stack</b>: the Sedona call stack (RAM)</li>
<li><b>Sedona Data</b>: all the memory declared as static 
fields in the current scode (RAM)</li>
<li><b>Sedona App</b>: the components which define the current application (RAM)</li>
<li><b>Sedona Code</b>: the scode image for the installed kits (RAM or FLASH)</li>
<li><b>SAB File</b>: the persistent storage of the application (FLASH) </li>
<li><b>C Code</b>: native code and SVM (FLASH or RAM)</li>
<li><b>C Data</b>: native code data segment (RAM)</li>
<li><b>C Stack</b>: the C native call stack (RAM)</li>
</ul>                          

<p>
We use the terms RAM and FLASH a bit loosely here:  RAM must be high 
speed read/write memory, and FLASH is persistent memory.  If FLASH is high
speed you might be able to run your code directly out of FLASH, otherwise you
will load code segments into RAM.
</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="computing">Computing Memory Requirements</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
So how do you figure out how much memory each of the sections 
declared above requires?  Let's look at each section:  
</p>   

<h2>C Code, Data, and Stack</h2>

<p>
The C code, data, and stack segments will be determined by your development 
tools and C compiler.  We use the term "C Code" to denote any non-Sedona code
used which might include C, C++, or assembly.  This code typically includes boot 
code, OS code (if you aren't running on bare metal), all your Sedona native method 
implementations, comm stacks, and the SVM itself.  During provisioning we 
lump all this stuff into a single file called "svm".  The C Data segment
includes all the memory buffers used by this code.
</p>                                                     

<h2>Sedona Stack</h2>

<p>
The Sedona stack is defined when you launch the VM in the <code>SedonaVM</code> 
struct by the <code>stackBaseAddr</code> and <code>stackMaxSize</code>.
Typically this value is one or two KB - although you should be able to test
your application to find the maximum call stack.  Heavy use of recursion and
methods with a large number of locals will effect your call stack size.
</p>                   

<h2>Sedona Code and Data</h2>

<p>
The Sedona Code and Data segments are computed when you compile your
scode image:
</p>

<pre>
D:\sedona>sedonac scode\x86-test.xml
  ReadKits [5 kits]
  WriteImage [D:\sedona\scode\x86-test.scode] (29632 bytes)
  +----------------------------------
  |  Data:      0.4kb (360 bytes)
  |  Code:     28.9kb (29632 bytes)
  |  Total:    29.3kb (29992 bytes)
  +----------------------------------
</pre>                       

<p>
If you are running your code out of RAM, then the total is what matters.  If
you can run your code out of FLASH, then Code will be FLASH, but Data must
be declared in RAM.  These numbers are directly related to how many kits
you include and the code size of those kits.  Declaring static fields will
consume memory in your Sedona Data segment.  Note that the <code>test</code>
and <code>debug</code> scode flags will have a huge impact on scode size.
</p>             

<p>
The location of the Sedona Code is passed to the VM in the <code>SedonaVM</code>
struct via the <code>codeBaseAddr</code> field.  The Sedona Data section
is allocated by the <code>malloc</code> macro - see "sedona.h" for details.
</p>

<h2>Sedona Application</h2>
 
<p>
The Sedona application itself is always run out of RAM.  This is where we
instantiate the components and links.  This memory is allocated
by the <code>malloc</code> macro.  If components or links are removed
during runtime, then this memory is freed by the <code>free</code> macro.
</p>

<p>
The Sedona application runs out of RAM, but has configuration data which
must be persistent between power cycles.  So we also store the 
application to FLASH as an <a href='apps.html#sab'>SAB file</a>.  How
this file is loaded on startup and stored back to FLASH on save is handled
by how your port implements the <code>sys::File</code> native methods.
</p>                 

<p>
Sedonac will report how much RAM and FLASH a given application 
consumes when you do a conversion between SAX or SAB:
</p>

<pre>               
D:\sedona>sedonac apps\test.sax
  ConvertAppFile [D:\sedona\apps\test.sax -> D:\sedona\apps\test.sab]
  +----------------------------------
  |  RAM:     14.2kb (14588 bytes)
  |  FLASH:    0.4kb (382 bytes)
  +----------------------------------
</pre>           

<p>
See the <a href='#layout'>Field Layout</a> section to evaluate how
much memory each component type consumes.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="heap">Heap</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The memory for the Sedona Data section and the memory for 
components and links in the App is allocated using the <code>malloc</code>
macro as defined in "sedona.h".  If components or links are removed
during runtime, then this memory is freed by the <code>free</code> macro.
You can implement your "heap management" using three strategies:
</p>                                                            

<ol> 
<li><b>Stdlib</b>: if you have the resources, you can just use C's built-in
malloc and free.  However if using a compiler like GCC this might
require importing a huge chunk of library code into your native image.</li>
<li><b>Custom Heap</b>: if the stdlib implementation of malloc and free is
too big, you might consider writing your own simple heap manager.</li>
<li><b>Malloc Only</b>: many devices might require only a static application
in which case there is no requirement for freeing memory.  In severly
limited devices, the ability to free memory would be pointless anyways 
because of heap fragmentation.  In this case your heap management might be
nothing more than a pointer to the next chunk of memory to allocate.</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="layout">Field Layout</h1>
<!--/////////////////////////////////////////////////////////-->

<p>    
You can use pass the <code>-layout</code> flag to sedonac when compiling
your scode image to dump the memory layout of each type.  This
gives you exact details for how memory is being consumed:
</p>

<ul>
<li>How many bytes each component type consumes in RAM</li>
<li>Memory offset of every instance field against the object's base address</li>
<li>Memory address of every static field against the Sedona Data base address</li>
</ul>                                

<p>
A good rule of thumb is that each component averages between 50 and 100 
bytes and each link consumes 16 bytes.  A network protocol service
will typically consume several KB since it must allocate buffers
and internal data structures.  However, you really must use the
<code>-layout</code> flag to see exactly how many bytes each component
will consume.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="hibernation">Hibernation</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona supports <i>hibernation</i> which allows a device to enter
a low power state.  Duration hibernation the Sedona's data section
in RAM (managed by the heap <code>malloc</code> and  <code>free</code> 
calls) must be maintained exactly.  The device can either maintain RAM 
during hibernation or save and restore to the same memory addresses.
</p>

<p>
To enter the hibernation state, an application calls <code>Sys.hibernate()</code>.
This will gracefully unwind the Sedona call stack and exit the VM with the
error code <code>ERR_HIBERNATE</code>.  The device's boot code should then
put the device to sleep.  It is a device dependent issue to decide how you
wake up from hibernation.  When the device does wake it up it should restart
the VM with a call to <code>vmUnhibernate(SedonaVM*)</code>.  If your device
doesn't support hibernation, then copy the code in "main.c" to just simulate
hibernation:
</p>

<pre>
result = vmRun(&amp;vm);
while (result == ERR_HIBERNATE)
{
  printf("-- Simulated hibernate --\n");
  result = vmUnhibernate(&amp;vm);
}
</pre>  

<p>
If you are developing Sedona components, applications, or drivers you should
keep hibernation in mind. Any software which might run on a battery powered 
device needs to support hibernation cleanly. This means that function blocks 
should assume the scan rate might have hibernation pauses. If you have 
services which need to do something special, then override: 
<code>Service.onHibernate()</code> and <code>Service.onUnhibernate()</code>.
</p>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='arrays.html'>Prev</a>
 | <a href='nativeMethods.html'>Next</a>
</div>
<div class='copyright'>Copyright &#169; 2007-2009 Tridium, Inc.</div>
</body>
<!-- TOC-FOOTER-END -->

</html>







