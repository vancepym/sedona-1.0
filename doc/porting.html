<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    30 Mar 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Porting</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='testing.html'>Prev</a>
 | <a href='sedonac.html'>Next</a>
</div>
<h1 class='title'>Porting</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="override">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The Sedona VM is designed to be easily ported to new hardware and
OS platforms using the following steps:
</p>

<ol>
<li>Add platform specific declarations to "sedona.h"</li>
<li>Decide which kits you are going to support - this will
    determine the list of native methods you need to support</li>
<li>Write custom implementations for native methods which
    are platform specific</li>
<li>Write your bootstrap code to run the VM</li>
<li>Stage your VM code using an XML build script</li>
<li>Compile the C code using your platform's C compiler</li>
<li>Run the test suite to verify a successful port</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="sedonaH">sedona.h</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Your porting journey starts with "<a href="../src/vm/sedona.h">sedona.h</a>"
which is sourced in the "src/vm" directory.  If you take 
a look at this file you can see that there is a section for major target
platforms such as Win32, QNX, and GCC.  Each platform section should 
be wrapped by an <code>#ifdef</code> directive for your target compiler/platform.
</p>

<p>
Follow the instructions at the top of the header file.  It lists
a whole bunch of types and macros which you must define correctly
including things like the ANSI C 99 integer types and macros for
endianness and block sizes.
</p>

<p>
If you wish your changes to be merged back into the standard
distribution, just email your changes back to us.  You can also
put your definitions into the "sedona-local.h" file which is included
by default if none of the existing "sedona.h" sections are matched.
</p>

<p>
You might also take a peek at the bottom of the "sedona.h" header
file.  This is where key types like <code>Cell</code> and
<code>SedonaVM</code> are defined as well as the function
declarations for working with the VM.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="natives">Natives</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The next step is to determine which kits to support.  For example
if you don't care about serial port connectivity, then you probably 
don't need to worry about the <code>serial</code> kit.  You also don't 
need to worry about kits which don't have native methods.  Once you have
selected your kits, you will have the complete list of native
methods which you must supply.  If you aren't boned up on all the
ins-and-outs of native methods, then review the
<a href="nativeMethods.html">Native Methods</a> chapter.
</p>

<p>
For every native method you will have to supply a C function
using the appropriate naming conventions which implements that
native method for your target platform.  Often you will be able
to use implementations which have already been written.  For
example some native methods like <code>sys::Sys.copy</code>
can be written in portable ANSI C.  Other methods, such as
<code>sys::Sys.ticks</code>, almost always require a custom
implementation for each hardware or OS platform.
</p>

<p>
Follow existing conventions for naming and organizing your native
code.  For example let's pretend we have a kit named "hogwarts"
which contains a class "Wizard" with a couple native methods.
Your source tree should be organized into the following directories:
</p>

<pre id="dirStruct">
hogwarts/
  +- native/
  |    +- qnx/
  |    |    +- hogwarts_Wizard_qnx.c
  |    +- win32/
  |    |    +- hogwarts_Wizard_win32.c
  |    +- hogwarts_Wizard.c
  +- test/
  |    +- WizardTest.sedona
  +- kit.xml
  +- Wizard.sedona
</pre>

<p>
All native code is organized under a directory called "native" under
the source base directory.  If you have native code which is portable
across <i>all</i> platforms then you create a C file per class using
the naming convention "<i>{kit}_{type}.c</i>" directly under the "native"
directory.
</p>

<p>
If you have native code which is specific to target platforms
then you create sub-directories under "native" for each platform.
For example "win32" is the standard name for Win32 target code.
Code under these directories is named using the convention
"<i>{kit}_{type}_{platform}.c</i>".  It is important to follow naming
conventions to ensure no file name collisions occur.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="bootstrap">Bootstrap</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
In addition to the native methods, you also need to write a
bit of C code to bootstrap the VM.  If you have access to stdlib
and a file system, then you can just use "<a href="../src/vm/main.c">main.c</a>"
which loads the scode from a file and boots the VM.
</p>

<p>
On many devices you won't be so lucky to have stdlib or a file
system.  In this case you need to perform the following initialization
using a <code>SedonaVM struct</code>:
</p>

<ol>
<li>Configure <code>codeBaseAddr</code> and <code>codeSize</code>
to point to your scode image.  Typically the scode is stored in FLASH
or loaded into RAM.  To get started you can compile the scode
into a big C string and link it into your executable using
the command line utility: <code>sedonac sedonac.util.CStrGen</code>.
</li>

<li>Configure <code>stackBaseAddr</code> and <code>stackMaxSize</code>
to point to an area of RAM which can be used for the Sedona stack.
</li>

<li>Configure <code>args</code> and <code>argsLen</code>
to pass in the arguments to the Sedona main method.  The <code>args</code>
pointer should reference a normal array of C null terminated strings (just
like a standard C main signature).
</li>

<li>Configure a callback function for <code>onAssertFailure</code>
to report assertion failures.  This is how you will know if
your <a href="testing.html">tests</a> are failing.
</li>

<li>Configure the <code>call</code> function pointer to point to
<code>vmCall</code>.  We use this indirection to allow patching a
ROM based VM.
</li>

<li>Configure a pointer to the <code>nativeTable</code> array generated
automatically during the VM code generation stage.  See
<a href="nativeMethods.html">Native Methods</a> chapter.
</li>

<li>Run the vm using the <code>vmRun()</code> function.  If
this function returns non-zero, then there is a problem.  Take
a look at "errorcodes.h" to see what the error might be.
</li>

<li>Consider your device's hibernation strategy.  Typically if 
<code>vmRun()</code> returns <code>ERR_HIBERNATE</code> then you should
put your device into a low-power state. Upon awaking you can re-enter
the vm using the <code>vmUnhibernate()</code> function.  See
the <a href='memory.html#hibernation'>Hibernation</a> section for
more details.
</li>

<li>After the VM exits normally you can use <code>assertSuccesses</code>
and <code>assertFailures</code> to report the number of calls
to <code>assert</code> which passed and failed.
</li>
</ol>

<p>
Even if you aren't using "<a href="../src/vm/main.c">main.c</a>",
you should still use it as a reference to help you write your
own bootstrap code.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="staging">Staging</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Now you should have an implementation for every native method:
either one already written or a custom native for your target
platform.  This code is spread out across the source tree in
oodles of directories.  The next step is to <i>stage</i> the VM
and native code which basically means copy the source files we need 
into one big flat directory so that we can compile them.
</p>

<p>
Staging is driven by a <a href='platforms.html#manifest'>platform XML</a> file
passed to <code>sedonac</code>. Here is the generic Windows platform XML file
which contains the compiler directives to stage the native code:
</p>

<pre>
&lt;sedonaPlatform id="generic-win32">

  &lt;compile endian="little" blockSize="4" refSize="4">
  
    &lt;!-- Native Kits -->
    &lt;nativeKit depend="sys  1.0" />
    &lt;nativeKit depend="inet 1.0" />

    &lt;!-- Native Sources -->
    &lt;nativeSource path="/src/vm" />
    &lt;nativeSource path="/src/sys/native" />
    &lt;nativeSource path="/src/sys/native/std" />
    &lt;nativeSource path="/src/sys/native/win32" />
    &lt;nativeSource path="/src/inet/native" />
    &lt;nativeSource path="/src/inet/native/std" />
    &lt;nativeSource path="/src/inet/native/sha1" />
      
  &lt;/compile>
       
&lt;/sedonaPlatform>
</pre>

<p>
The platform XML file lists of all the directories containing the C files we
need to compile for our target platform. For example to implement all the
native methods for the <code>sys</code> kit we pull from the common "native"
directory which is the portable code. We pull from "native/std" which is
portable if using stdlib. And we pull from "native/win32" which is win32
specific code. We also need the "src/vm" code itself and we use the standard
bootstrap code from "src/boot/std". You can take advantage of the platform
database's ability to include other platform files if you have multiple
binaries to build.
</p>

<p>
You run the staging script by passing the platform XML file and
the target directory via the <code>-outDir</code> option.  For
example to stage generic win32 might look like this:
</p>

<pre>       
  sedonac platforms/generic/win32/generic-win32.xml -outDir tempStageDir
</pre>

<p>
The compiler will nuke the stage directory to start fresh, copy the source 
files to the stage directory, and generate a file called "nativetable.c"
which specifies the native function lookup 
<a href="nativeMethods.html#tables">tables</a>.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="wrapUp">Wrap Up</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Once you stage the VM code, you have one big flat directory of
all the source files needed to compile a complete VM.  This makes
it easy to run your C compiler using something like "cc *.c".
</p>

<p>
Once you have successfully built your VM executable, you should
run the <a href="testing.html">test harness</a> to verify a
successful port.
</p>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='testing.html'>Prev</a>
 | <a href='sedonac.html'>Next</a>
</div>
<div class='copyright'>Copyright &#169; 2007-2009 Tridium, Inc.</div>
</body>
<!-- TOC-FOOTER-END -->

</html>
