<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    29 Mar 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Primitives</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='lang.html'>Prev</a>
 | <a href='expr.html'>Next</a>
</div>
<h1 class='title'>Primitives</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The Sedona programming language contains the following built-in
primitive types:
</p>

<ul>

<li><code>bool</code>: boolean of <code>true</code> or <code>false</code></li>

<li><code>byte</code>: unsigned 8-bit integer (fields/arrays only)</li>

<li><code>short</code>: unsigned 16-bit integer (fields/arrays only)</li>

<li><code>int</code>: signed 32-bit integer</li>

<li><code>long</code>: signed 64-bit integer</li>

<li><code>float</code>: 32-bit floating point</li>

<li><code>double</code>: 64-bit floating point</li>

</ul>

<p>
In addition to the primitive types, the following Obj types have special
language support for literal representation:
</p>

<ul>

<li><code>Str</code>: string of ASCII characters terminated by 0 (like C string)</li>
<li><code>Buf</code>: chunk of bytes in memory</li>

</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="bool">Bool</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The <code>bool</code> type stores a boolean variable.  Boolean
literals are expressed using the <code>true</code>, <code>false</code>
and <code>null</code> keywords.  Use <code>null</code> to indicate 
an invalid boolean value.  If used in a boolean expression, <code>null</code> 
will evaluate to true (it is represented as 2 in memory).
</p>

<p>
A <code>bool</code> is stored in fields and arrays as an unsigned
8-bit integer.  During stack manipulation <code>bools</code> are
stored on the stack as signed 32-bit integers.
</p>

<p>
The represenation for booleans:
</p>      

<table border='1'> 
<tr><th>Value</th><th>Binary</th><th>String</th></tr>
<tr><td><code>false</code></td> <td>0</td> <td>"false"</td></tr>
<tr><td><code>true</code></td>  <td>1</td> <td>"true"</td></tr>
<tr><td><code>null</code></td>  <td>2</td> <td>"null"</td></tr>
</table>

<!--/////////////////////////////////////////////////////////-->
<h1 id="integers">Integers</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona provides four integer types of varying widths:
</p>

<ul>
<li><code>byte</code>: unsigned 8-bit integer (fields/arrays only)</li>
<li><code>short</code>: unsigned 16-bit integer (fields/arrays only)</li>
<li><code>int</code>: signed 32-bit integer</li>
<li><code>long</code>: signed 64-bit integer</li>
</ul>

<p>
Note that unlike Java both <code>byte</code> and <code>short</code> 
are <i>unsigned</i>.  Currently there is no signed 8-bit or 16-bit 
integer type.
</p>

<p>
Both <code>byte</code> and <code>short</code> are special types
which may only be used as fields or in arrays.  All integer operations
on the Sedona VM stack are performed using signed 32-bit integers.
When a <code>byte</code> and <code>short</code> is loaded from a
field or array it is automatically expanded into a 32-bit signed
value.  Likewise when it is stored back into a field or array it
is narrowed from a 32-bit signed value.  Attempting to use <code>byte</code>
or <code>short</code> as a return type, parameter type, or local variable
type is a compiler error.
</p>

<p>
Integer literals are decimal by default. If prefixed with "0x" they are
hexadecimal.  You may use the underbar "_" as separator in both
decimal or hexadecimal formats.  To specify a 64-bit long you must append
a "l" or "L" suffix.  You may also use single quotes to specify a character 
as an integer literal.  The following character escape sequences are supported:
</p>

<pre id="charEscapes">
  \0   zero/null terminator
  \n   newline
  \r   carriage return
  \t   horizontal tab
  \"   double quote
  \'   single quote
  \\   forward slash   
  \$   dollar sign ($ is used for <a href='expr.html#interpolation'>str interpolation</a>)
</pre>

<p>
Examples of integer literals:
</p>

<pre>
8
-78
0xABCD
10_000
0xffff_ffff
'x'
'\n'
0L
0x1234_5678_aabb_ccddL
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="floats">Floating Point</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The <code>float</code> type maps to a 32-bit floating point 
value and <code>double</code> to 64-bit floating point.
</p>

<p>
Floating point literals are expressed in decimal format using a "."
dot as the decimal point.  The "F" or "f" character may be used as
a suffix (required if not using a decimal point).  The "D" or "d" 
character is rquired as a suffix for a 64-bit double.  Currently
Sedona does not support exponential notation.  You may use the "_"
underbar as a separator.
</p>

<p>
The keyword <code>null</code> is used to represent not-a-number
for situations requiring indication of an invalid float or double.  
The string representation for <code>null</code> floats and doubles
is always "null".  The "==" operator will return true when comparing
two <code>null</code> floating point values (different than Java
and IEEE).  How arithmetic and comparisions operate with <code>null</code> 
is unspecified by the Sedona VM.
</p>

<pre>
3f
3.0
40_000F
-2.00D
0d
null
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="time">Time</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona models time as a 64-bit long as a number of nanosecond ticks.
When working with time, Sedona supports a special literal representation
for <code>longs</code> using the following suffixes on a decimal number:
</p>

<table border='1'>
<tr> <th>Suffix</th> <th>Unit</th>     <th>Nanosecond Multiplier</th> </tr>
<tr> <td>ns</td>     <td>nanoseconds</td>  <td>1</td> </tr>
<tr> <td>ms</td>     <td>milliseconds</td> <td>1,000,000</td> </tr>
<tr> <td>sec</td>    <td>seconds</td>      <td>1,000,000,000</td> </tr>
<tr> <td>min</td>    <td>minutes</td>      <td>60,000,000,000</td> </tr>
<tr> <td>hr</td>     <td>hours</td>        <td>3,600,000,000,000</td> </tr>
<tr> <td>days</td>   <td>days</td>         <td>86,400,000,000,000</td> </tr>
</table>

<p>
Examples of <code>long</code> time literals and what they represent:
</p>

<pre>
5ns          // 5L
1ms          // 1_000_000L
10sec        // 10_000_000_000L
3min         // 180_000_000_000L
12hr         // 43_200_000_000_000L
0.5ms        // 500_000L
0.001sec     // 1_000_000L
0.25min      // 15_000_000_000L
0.5days      // 43_200_000_000_000L
1days        // 86_400_000_000_000L
36500days    // 31_53_600_000_000_000_000L
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="str">Str</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The <code>sys::Str</code> class models a string of ASCII characters.
Sedona strings are stored in memory like C strings using a null
terminator (a byte value of zero).  You should limit yourself to 7-bit
ASCII characters (high bit is clear) for future UTF-8 and Unicode
support.
</p>

<p>
The internal representation of a Str differs between the SVM and the 
JVM.  For the most part the Str APIs hide any storage differences between
the SVM and JVM platforms.  But it helps to know what is going on under
the covers:
</p>

<p>
In the SVM, the <code>Str</code> class makes use of the 
<a href="arrays.html#unsizedClasses">unsized class</a> feature such that 
it contains a variable length, inline <code>byte[]</code>.  No other fields 
are declared, which means that an instance of <code>Str</code> is stored 
in memory just like a <code>byte[]</code>.  You can also treat a <code>Str</code> 
reference as a normal C string (<code>char*</code>) when writing your 
<a href="nativeMethods.html">native methods</a>.
</p>                                            

<p>
On the Java VM, Str is represented by the <code>sedona.vm.StrRef</code> class
which encapsulates a reference to a <code>byte[]</code> and an offset
into that byte array.  This allows us simulate "pointer arithmetic" when
parsing strings out of static buffers.
</p>                     

<p>
<code>Str</code> literals are written using double quotes.  You may use
the standard <a href="#charEscapes">escape sequences</a> inside the quotes
for special characters.  All <code>Str</code> literals are <i>interned</i>
when compiling a scode image - this means that all <code>Str</code> literals
with the same sequence of characters will share the same reference.  Str
literals are stored in the scode memory space - never attempt
to write to a Str literals memory.
</p>

<p>
Examples of <code>Str</code> literals:
</p>

<pre>
"hello"
"Hi there.\nHow are you?"
</pre>

<p>
Note that the compiler automatically adds the null terminator.  For example
a pointer to the literal <code>"abc"</code> is really a pointer to four bytes
of memory storing <code>"abc\0"</code>.  <code>Str</code> literals should
be considered read-only memory - never try to change the contents of
a <code>Str</code> literal.
</p>

<p>
Because <code>Str</code> is an <a href="arrays.html#unsizedClasses">unsized class</a>,
you must specify the length of the string when declaring an inline <code>Str</code>.
For example to declare a <code>Str</code> which can hold a max of 8
characters (including the null terminator):
</p>

<pre>
Str someStr           // reference to Str
inline Str(8) myStr   // storage for 8 byte Str
</pre>                 

<p>
Sedona also supports <a href='expr.html#interpolation'>str interpolation</a>.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="buf">Buf</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The <code>sys::Buf</code> class models a contiguous chunk of bytes 
in memory.  The syntax for a Buf literal is <code>0x[<i>hexDigits</i>]</code>.
You can use whitespace including newlines between bytes (not nibbles).
For example:
</p>          

<pre>
static Buf literalA = 0x[cafe babe 03 dead beef]
</pre>   

<p>
Just like Str literals, Buf literals are interned and stored in scode
memory space.  So you should never attempt to write into a Buf literal's
memory space - for example never try to set the <code>bytesLen</code> field 
or change the contents of the <code>bytes</code> field.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="arrayLiterals">Array Literals</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Although they are not free-form expressions, you can also 
declare array literals in code:
</p>

<pre>  
define Str[] colors = {"red", "green", "blue"}
</pre>

<p>
See <a href='fields.html#arrayLiterals'>Array Literals</a> for more details.
</p>


<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='lang.html'>Prev</a>
 | <a href='expr.html'>Next</a>
</div>
<div class='copyright'>Copyright &#169; 2007-2009 Tridium, Inc.</div>
</body>
<!-- TOC-FOOTER-END -->

</html>







