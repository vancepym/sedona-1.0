//
// Copyright (c) 2007 Tridium, Inc
// Licensed under the Academic Free License version 3.0
//
// History:
//   5 Jun 07  Brian Frank        Creation
//  27 Feb 09  Elizabeth McKenney Add buffering for single-byte writes
//

**
** File is used to manage I/O to a "file".  On simple
** embedded devices a file is typically just an area of FLASH.
**
final class File
{                   

//////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////

  **
  ** File constructor.
  **
  File()
  {
    out.file = this
    in.file = this
  }

//////////////////////////////////////////////////////////////////////////
// Methods
//////////////////////////////////////////////////////////////////////////

  **
  ** Return if the file identified by name exists on the file system.
  ** This method may used without opening the file.
  **
  bool exists()
  {
    return size() >= 0
  }

  **
  ** Return the size in bytes of the file, or -1 if the file does
  ** not exist or cannot currently be accessed (e.g. if open for
  ** writing).  This method may used without opening the file.
  **
  int size()
  {
    return doSize(name)
  }

  **
  ** Open the file using the configured name field.  Mode
  ** is a string how IO will be performed:
  **   - "r": open for reading
  **   - "w": open for writing (truncate existing)
  **   - "m": open for modification and read/writing (don't truncate)
  ** Return true on success or false on error.
  **
  ** Note although the mode strings are passed as simply "r", "w", or
  ** "m", it is expected that files are always opened for binary
  ** IO - for example "w" maps to the C fopen mode of "wb".
  **
  bool open(Str mode)
  {
    this.fp = doOpen(name, mode);
    if (fp == null) return false
    this.mode = mode
    return true
  }

  **
  ** Close this file.  Return true on success or false on failure.
  ** If the file isn't open, this method immediately returns true.
  **
  bool close()
  {
    bool ok = true
    if (fp != null)
    {
      in.close()
      out.close()
      ok = doClose(fp, name, mode)
      this.fp = null
      this.mode = null
    }
    return ok
  }
  
  **
  ** Return the current byte offset position of the file.  
  ** Use seek to change the current position.
  **
  int tell()
  {
    out.flush()  // flush any buffered output before querying file pos   
    return doTell(fp)
  }  

  **
  ** Seek to a specific byte offset position in the file.
  ** Return true on success or false on failure.  A failure
  ** typically indicates a seek past the file limit of the
  ** device's "file system".  Use tell to read the current
  ** position.
  **
  bool seek(int pos)
  {    
    out.flush()  // flush any buffered output before changing file pos   
    return doSeek(fp, pos)
  }             
  
  **
  ** Rename a file. Return true on success, false on failure.
  **
  native static bool rename(Str from, Str to)

//////////////////////////////////////////////////////////////////////////
// Natives
//////////////////////////////////////////////////////////////////////////

  internal native static int doSize(Str name)
  internal native static Obj doOpen(Str name, Str mode)
  internal native static int doRead(Obj fp)
  internal native static int doReadBytes(Obj fp, byte[] b, int off, int len)
  internal native static bool doWrite(Obj fp, int b)
  internal native static bool doWriteBytes(Obj fp, byte[] b, int off, int len)
  internal native static bool doSeek(Obj fp, int pos)
  internal native static int  doTell(Obj fp)
  internal native static void doFlush(Obj fp)
  internal native static bool doClose(Obj fp, Str name, Str mode)

//////////////////////////////////////////////////////////////////////////
// Fields
//////////////////////////////////////////////////////////////////////////

  Obj fp                    // native handle for open file
  Str name                  // name of the file
  inline FileOutStream out  // stream to write file (buffered)
  inline FileInStream in    // stream to read file
  internal Str mode         // mode string if open
}

****************************************************************
** FileOutStream
****************************************************************
//
// This version is modelled in part on BufOutStream.
//   Single-byte writes are buffered, but block writes are not.
//   This minimizes code size, but is inefficient for small block 
//   writes, or single-byte writes mixed in with block writes.
//   It is assumed that in general files will be written
//   exclusively via single-byte writes OR moderately-sized
//   block writes.
//
internal class FileOutStream extends OutStream
{
  override bool write(int b) 
  { 
    // If buffer is full, write contents to file
    if (fbuf.size >= fbuf.bytesLen) 
    {
      if (!writeBufToFile()) return false
    }
    fbuf.bytes[fbuf.size++] = b
    return true
  }

  override bool writeBytes(byte[] b, int off, int len) 
  {
    // Write any accumulated data in buf first
    if (fbuf.size>0) writeBufToFile()

    // Now write contents of b
    return File.doWriteBytes(file.fp, b, off, len) 
  }

  override void flush() 
  { 
    if (fbuf.size>0) writeBufToFile()
    File.doFlush(file.fp) 
  }

  override void close() { if (fbuf.size>0) writeBufToFile() }

  internal bool writeBufToFile()
  { 
    // Write contents of buf to file
    if (!File.doWriteBytes(file.fp, fbuf.bytes, 0, fbuf.size)) 
      return false

    // Clear contents of buf
    fbuf.clear()
    return true
  }

  inline Buf(32) fbuf             // internal buffer for single-byte writes

  internal File file
}


****************************************************************
** FileInStream
****************************************************************

internal class FileInStream extends InStream
{
  override int read() { return File.doRead(file.fp) }
  override int readBytes(byte[] b, int off, int len) 
  { 
    return File.doReadBytes(file.fp, b, off, len) 
  }

  override void close() { /* file.close() */ }

  internal File file
}
