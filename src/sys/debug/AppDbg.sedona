//
// Copyright (c) 2010 Tridium, Inc
// Licensed under the Academic Free License version 3.0
//
// History:
//   02 Feb 2010  Clif Turman  Creation
//   08 Feb 2010  Clif Turman  Added MinMin and MaxMax properties
//                             Changed scanCyclesPerUpdate default to 1000
//                             Rearranged property ordering
//

**
** AppDbg is an optional component which displays performance data on the scan engine
** This object should only be used during tuning of an application
** and should not be a permanent part.
** Note that inclusion of this component increases the execute
** cycle time and memory footprint, so it is not "non-invasive"
**
@niagaraIcon="module://icons/x16/bug.png"
class AppDbg
  extends Component
{
	**
	** Over how many scans to update statistics
	** Actual time = (App.scanPeriod) * (scanCyclesPerUpdate)
	** Does not begin calculation until App.isSteadyState is reached
	**
	@summary=false
	@config
  property int scanCyclesPerUpdate = 1000

  **
  ** Execution time for component tree for previous scan.
  ** Calculated every scan, but updated only
  ** once per scanCyclesPerUpdate scans.
  ** execTime = App.lastStartWork - App.lastStartExec
  **
  //@summary=false
	//@unit=Units.millisecond
  //@readonly property float execTime

  **
  ** Average execute time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float execTimeAvg

  **
  ** Min execute time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float execTimeMin

  **
  ** Max execute time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float execTimeMax

  **
  ** Min of all execTimeMin since boot or since last "resetValues"
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float execTimeMinMin

  **
  ** Max of all execTimeMax since boot or since last "resetValues"
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float execTimeMaxMax

  **
  ** Average work time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float workTimeAvg

  **
  ** Min work time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float workTimeMin

  **
  ** Max work time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float workTimeMax

  **
  ** Min of all workTimeMin since boot or since last "resetValues"
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float workTimeMinMin

  **
  ** Max of all workTimeMax since boot or since last "resetValues"
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float workTimeMaxMax

  **
  ** Average scan time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float scanTimeAvg

  **
  ** Min scan time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float scanTimeMin

  **
  ** Max scan time over scanCyclesPerUpdate scans
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float scanTimeMax

  **
  ** Min of all scanTimeMin since boot or since last "resetValues"
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float scanTimeMinMin

  **
  ** Max of all scanTimeMax since boot or since last "resetValues"
  **
  @summary=false
  @unit=Units.millisecond
  @readonly property float scanTimeMaxMax

  ** total number of overruns (actual scan time exceeds desired scan time)
  ** A steadily increasing number here indicates a scan time too small (execute time +
  ** work time exceeds scan time).  Occasional overruns are to be expected.
  @summary=false
  @readonly property int overruns = 0

  virtual override void start()
  {
  	tmpExecTimeMin = (float)Sys.maxInt
    tmpWorkTimeMin = (float)Sys.maxInt
    tmpScanTimeMin = (float)Sys.maxInt
    tmpExecTimeMax = 0.0
    tmpWorkTimeMax = 0.0
    tmpScanTimeMax = 0.0
    tmpExecTime = 0.0
    tmpWorkTime = 0.0
    tmpScanTime = 0.0
  	resetValues()
  }

  **
  ** Calculate and cache previous scan's times every scan
  **
  virtual override void execute()
  {
  	if(!Sys.app.isSteadyState())
  	  return

  	//cache calculated values for last scan cycle
    tmpExecTime = ((float)(Sys.app.lastStartWork - Sys.app.lastStartExec))*1e-6
    tmpWorkTime = ((float)(Sys.app.lastEndWork   - Sys.app.lastStartWork))*1e-6
    tmpScanTime = ((float)(Sys.app.newStartExec  - Sys.app.lastStartExec))*1e-6

    //compute new execution time max/min
    tmpExecTimeMax = tmpExecTime > tmpExecTimeMax ? tmpExecTime : tmpExecTimeMax
    tmpExecTimeMin = tmpExecTime < tmpExecTimeMin ? tmpExecTime : tmpExecTimeMin
    
    //compute new work time max/min
    tmpWorkTimeMax = tmpWorkTime > tmpWorkTimeMax ? tmpWorkTime : tmpWorkTimeMax
    tmpWorkTimeMin = tmpWorkTime < tmpWorkTimeMin ? tmpWorkTime : tmpWorkTimeMin

    //compute new actual scan time max/min
    tmpScanTimeMax = tmpScanTime > tmpScanTimeMax ? tmpScanTime : tmpScanTimeMax
    tmpScanTimeMin = tmpScanTime < tmpScanTimeMin ? tmpScanTime : tmpScanTimeMin

    //see if we have any overruns and update
    if(tmpScanTime > (float)Sys.app.scanPeriod + 1.0)
      overruns++

    //compute averages
    if(Sys.app.cycleCount % (long)scanCyclesPerUpdate == 0L)
    {
      //update fast changing properties every scanCyclesPerUpdate scans to prevent sox message flooding
      execTime = tmpExecTime
      workTime = tmpWorkTime
      scanTime = tmpScanTime
      
      execTimeMin = tmpExecTimeMin
      execTimeMax = tmpExecTimeMax
      workTimeMin = tmpWorkTimeMin
      workTimeMax = tmpWorkTimeMax
      scanTimeMin = tmpScanTimeMin
      scanTimeMax = tmpScanTimeMax

      if(first)
      {
      	first = false
        execTimeMinMin = execTimeMin
        execTimeMaxMax = execTimeMax
        workTimeMinMin = workTimeMin
        workTimeMaxMax = workTimeMax
        scanTimeMinMin = scanTimeMin
        scanTimeMaxMax = scanTimeMax
      }
      else
      {
        execTimeMinMin = execTimeMin < execTimeMinMin ? execTimeMin : execTimeMinMin
        execTimeMaxMax = execTimeMax > execTimeMaxMax ? execTimeMax : execTimeMaxMax
        workTimeMinMin = workTimeMin < workTimeMinMin ? workTimeMin : workTimeMinMin
        workTimeMaxMax = workTimeMax > workTimeMaxMax ? workTimeMax : workTimeMaxMax
        scanTimeMinMin = scanTimeMin < scanTimeMinMin ? scanTimeMin : scanTimeMinMin
        scanTimeMaxMax = scanTimeMax > scanTimeMaxMax ? scanTimeMax : scanTimeMaxMax
      }
      

      //compute and update averages
      execTimeAvg = execTimeRunningTotal/(float)scanCyclesPerUpdate
      workTimeAvg = workTimeRunningTotal/(float)scanCyclesPerUpdate
      scanTimeAvg = scanTimeRunningTotal/(float)scanCyclesPerUpdate

      //reset running totals
      execTimeRunningTotal = 0.0
      workTimeRunningTotal = 0.0
      scanTimeRunningTotal = 0.0
      
      tmpExecTimeMax = 0.0
      tmpExecTimeMin = (float)Sys.maxInt
      tmpWorkTimeMax = 0.0
      tmpWorkTimeMin = (float)Sys.maxInt
      tmpScanTimeMax = 0.0
      tmpScanTimeMin = (float)Sys.maxInt
      
    }
    
    //accumulate times for averaging
    execTimeRunningTotal += tmpExecTime
    workTimeRunningTotal += tmpWorkTime
    scanTimeRunningTotal += tmpScanTime
  }
  
  **
  ** Reset the max value calculations and the overruns value
  **
  action void resetValues()
  {
    first = true
    execTimeMaxMax = 0.0
    execTimeMinMin = (float)Sys.maxInt
    //execTimeAvg = 0.0
    //execTimeRunningTotal = 0.0
    workTimeMaxMax = 0.0
    workTimeMinMin = (float)Sys.maxInt
    //workTimeAvg = 0.0
    //workTimeRunningTotal = 0.0
    scanTimeMaxMax = 0.0
    scanTimeMinMin = (float)Sys.maxInt
    //scanTimeAvg = 0.0
    //scanTimeRunningTotal = 0.0
    overruns = 0
  }

  internal float execTime
  internal float workTime
  internal float scanTime
  internal float tmpExecTime
  internal float tmpWorkTime
  internal float tmpScanTime  
  internal float tmpExecTimeMax
  internal float tmpWorkTimeMax
  internal float tmpScanTimeMax
  internal float tmpExecTimeMin
  internal float tmpWorkTimeMin
  internal float tmpScanTimeMin
  internal float execTimeRunningTotal
  internal float workTimeRunningTotal
  internal float scanTimeRunningTotal
  bool first
  
}
